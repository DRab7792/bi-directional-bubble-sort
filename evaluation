	The code created by the gcc compiler for both the 32 bit and 64 bit versions in order to meet the constraints defined in the inline assembly falls under the label ".L2." This is made clear by the position of the label ".L2" as well as the block of code that is contained by ".L2." Both versions of the code are fairly similar with the exception of the register names and the memory sizes. However, it is obvious that ".L2" is where the constraints are set up by the compiler due to the code. In the beginning of ".L2" data is being moved throughout the registers, tested and shifted, making it somewhat difficult to figure out what data is being manipulated. However, in both the 32 bit and 64 bit versions the ".L2" block ends with around 10 move statements all moving data from the stack into the registers, setting up the inline assembly code to work. Following the ".L2" block in both versions is the actual assembly that I wrote for the bi-directional bubble sort algorithm. Another reason why ".L2" is the obvious block of code that sets up the constraints for the inline block is because the code before that block, which is labeled ".L3" in both versions of assembly. The block of code labeled ".L3" can be translated to:
		arr[size] = buffer;
		++size;
		printf("Enter a number: ");
		scanf("%ld", &buffer);
	The first few lines of assembly in both versions of assembly are equivalent to "arr[size] = buffer," as seen by the movement between the stack and registers. Then, the assembly written in both versions is "addl	$1, -x(%ebp)" where only x differs. This can be written in C as "++size;." Then the assembly prints a string with the value "Enter a number: " and calls a scan function.
	Upon overall examination of the assembly from both the 32 bit and 64 bit versions one can recognize that each ".L" label is a placeholder for the C comments from the original code, making it even easier to locate the constraint code at the end of the ".L3" block.
