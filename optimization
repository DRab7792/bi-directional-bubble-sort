Optimization Level 1

	Upon first glance at the newly optimized code I first noticed the change in the number of lines of assembly code between the optimized code and the original assembly code. While both versions showed a decrease in the amount of code, the 32 bit version showed a more significant decrease than the 64 bit version.
	The first major change in the code in both versions is the structure of the .cfi commands. In the original assembly the .cfi commands are called in a random order, whereas in the optimized code they are in a specific order, usually followed by push commands. This implies that the optimization is setting up the stack in a more efficient manner. The next change in the code is additional jump statements right before the block labeled ".L7," which was also an added label created by optimization. More conditions are placed in the optimized code in both versions resulting in more efficient branches and thread jumps. In both versions of architecture there are several more cases of the compiler making loops and conditional blocks more efficient by adding labels and jumps, minimizing the code within the conditional block. This can be seen in both versions by the "call malloc" and "call free" commands. In both optimized versions these call statements come much earlier than in the unoptimized code. Also, in both optimized versions of code there is a lot more use of the (#,#,#) notation to index through memory. Finally, another major difference between the optimized and unoptimized code is the portion of code prior to the inline assembly, where the constraints are set up. In both unoptimized versions setting up the constraints requires quite a few move statements. However, a more efficient method is used in the first level of optimization, which shortens the code into an lea statement and several moves instead.
	Upon comparison of the two different architectures being optimized the only notable difference between the two is in the beginning, where more .cfi commands are needed for the 64 bit architecture, making it slightly more code than the 32 bit version. However, overall the first level of optimization cut about 10-20 lines of code off and optimized it to run faster and more efficiently.

